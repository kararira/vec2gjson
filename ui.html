<style>
  body { font-family: sans-serif; text-align: center; padding: 16px; }
  button {
    background-color: #0d99ff; color: white; border: none; padding: 10px 20px;
    border-radius: 4px; font-size: 14px; cursor: pointer; display: block; width: 100%; margin-bottom: 8px;
  }
  button:disabled { background-color: #e0e0e0; cursor: not-allowed; }
  p { font-size: 12px; color: #555; }
  /* ★ 追加: 一括ボタン用のスタイル */
  .master-buttons { border-bottom: 2px solid #0d99ff; padding-bottom: 16px; margin-bottom: 16px; }
  .master-buttons button.walkable { background-color: #28a745; }

  .floor-group { border: 1px solid #ccc; border-radius: 8px; padding: 12px; margin-bottom: 12px; }
  .floor-title { font-weight: bold; margin-bottom: 8px; }
  .floor-buttons { display: flex; gap: 8px; }
  .floor-buttons button { width: 50%; font-size: 12px; padding: 8px; }
  .floor-buttons button.walkable { background-color: #28a745; }
</style>

<h2>GeoJSON エクスポート</h2>
<p id="message">データを待っています...</p>

<div id="master-buttons-area" class="master-buttons" style="display: none;">
  <button id="export-all-master-button">全てのGeoJSONを一括保存</button>
  <button id="generate-all-master-button" class="walkable">全ての歩行可能エリアを一括生成</button>
</div>
<div id="separated-buttons-area"></div>

<script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/earcut/dist/earcut.min.js"></script>
<script>
  const masterButtonsArea = document.getElementById('master-buttons-area');
  const exportAllMasterButton = document.getElementById('export-all-master-button');
  const generateAllMasterButton = document.getElementById('generate-all-master-button');
  const separatedButtonsArea = document.getElementById('separated-buttons-area');
  const messageEl = document.getElementById('message');
  
  let allFloorsData = null;
  let filenamePrefix = 'map';

  // (downloadJson関数とfixWindingOrder関数は変更なし)
  function downloadJson(jsonData, fileName) {
    const blob = new Blob([jsonData], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url; link.download = fileName;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    return new Promise(resolve => setTimeout(resolve, 100));
  }

  function fixWindingOrder(geoJsonData) {
    const correctedFeatures = geoJsonData.features.map((feature) => {
      return turf.rewind(feature, { inplace: false });
    });
    return { type: 'FeatureCollection', features: correctedFeatures };
  }

  // ★★★ 追加: ピクセル座標で円ポリゴンを生成するヘルパー関数 ★★★
  /**
   * 中心点と半径（ピクセル単位）から、円を近似するポリゴンフィーチャーを作成します。
   * @param {number[]} center - [x, y]の中心座標
   * @param {number} radius - 半径 (ピクセル)
   * @param {object} properties - フィーチャーに付与するプロパティ
   * @returns {object} GeoJSONのPolygon Feature
   */
  function createCirclePolygon(center, radius, properties) {
    const steps = 64; // 円を64角形で近似
    const coordinates = [];
    for (let i = 0; i < steps; i++) {
      const angle = (i / steps) * 2 * Math.PI;
      const x = center[0] + radius * Math.cos(angle);
      const y = center[1] + radius * Math.sin(angle);
      coordinates.push([x, y]);
    }
    coordinates.push(coordinates[0]); // ポリゴンを閉じる
    return turf.polygon([coordinates], properties);
  }

  // ★★★ ピクセル座標系で動作する正方形分割用の自作関数 ★★★
  /**
   * ポリゴンを指定されたセルサイズで正方形のグリッドに分割します。
   * @param {Feature<Polygon|MultiPolygon>} polygonFeature - 分割対象のポリゴンフィーチャ。
   * @param {number} cellSize - 正方形の一辺の長さ（ピクセル単位）。
   * @returns {Feature<Polygon>[]} - 分割されて生成された正方形ポリゴンのフィーチャ配列。
   */
  function createSquareGridInPolygon(polygonFeature, cellSize) {
    const gridFeatures = [];
    if (!polygonFeature || !polygonFeature.geometry) return gridFeatures;

    // 1. ポリゴンのバウンディングボックスを取得
    const bbox = turf.bbox(polygonFeature);
    const [minX, minY, maxX, maxY] = bbox;

    // 2. バウンディングボックス内を格子状にループ
    for (let x = minX; x < maxX; x += cellSize) {
      for (let y = minY; y < maxY; y += cellSize) {
        // 3. 各格子の中心点を計算
        const centerX = x + cellSize / 2;
        const centerY = y + cellSize / 2;
        const centerPoint = turf.point([centerX, centerY]);

        // 4. 中心点がポリゴン内に含まれているかチェック
        if (turf.booleanPointInPolygon(centerPoint, polygonFeature)) {
          // 5. 含まれている場合、その格子を正方形ポリゴンとして生成
          const squareCoords = [[
            [x, y],
            [x + cellSize, y],
            [x + cellSize, y + cellSize],
            [x, y + cellSize],
            [x, y] // ポリゴンを閉じる
          ]];
          gridFeatures.push(turf.polygon(squareCoords));
        }
      }
    }
    return gridFeatures;
  }


  // ★★★ 追加: 個別処理を関数化 ★★★

  // 1フロア分のGeoJSONを保存する関数
  function handleSaveGeoJson(floorData) {
    const corrected = fixWindingOrder(floorData.geoJson);
    const fileName = `${floorData.frameId}.geojson`;
    return downloadJson(JSON.stringify(corrected, null, 2), fileName);
  }

  // 1フロア分の歩行可能エリアを生成・保存する関数
  function handleGenerateWalkable(floorData) {
    try {
      const { frameId, geoJson } = floorData;
      const base = geoJson.features.find(f => f.properties.id === 'base');
      if (!base) {
        throw new Error(`フロア "${frameId}" に "base" が見つかりません。`);
      }
      // const stairs = geoJson.features.filter(f => f.properties.id.includes('stairs'));
      const pre_obstacles = geoJson.features.filter(f => f.properties.id !== 'base');
      // 障害物リストの中にある円（Point）をポリゴンに変換
      // ★ 変更点: turf.circleの代わりに自作関数を使う
      const obstacles = pre_obstacles.map(obstacle => {
          if (obstacle.geometry.type === 'Point' && obstacle.properties.radius) {
              const center = obstacle.geometry.coordinates;
              const radius = obstacle.properties.radius;
              // ★ 自作のcreateCirclePolygon関数を呼び出す
              return createCirclePolygon(center, radius, obstacle.properties);
          }
          return obstacle;
      });

      let walkableArea = base;
      obstacles.forEach(obs => {
        // ★★★ デバッグ用のチェックを追加 ★★★
        const doTheyOverlap = turf.booleanOverlap(walkableArea, obs);
        const isContained = turf.booleanContains(walkableArea, obs);

        // console.log(`障害物チェック: ${obs.properties.id}`);
        // console.log(`  - 重なっていますか？ -> ${doTheyOverlap}`);
        // console.log(`  - 床に完全に含まれていますか？ -> ${isContained}`);
        
        if (!isContained && !doTheyOverlap) {
          console.log(`障害物チェック: ${obs.properties.id}`);
          console.error(`  - 警告: この障害物は床ポリゴンと重なっていないため、引き算できません！座標を確認してください。`);
          console.log(obs);
        }
        // ★★★ チェックここまで ★★★

        // 安全のため、演算の前に両方のジオメトリをクリーンアップ
        const cleanedWalkable = turf.cleanCoords(walkableArea);
        const cleanedObs = turf.cleanCoords(obs);

        // turf.difference(polygon1, polygon2) の形で呼び出す
        // turf.differenceはnullを返すことがあるので、結果をチェック
        const result = turf.difference(turf.featureCollection([cleanedWalkable, cleanedObs]));
        
        if (result) {
          walkableArea = result;
        } else {
          console.warn(`差分計算に失敗しました。障害物オブジェクトを確認してください:`, obs.properties.id);
        }
      });
      // stairs.forEach(s => {
      //   walkableArea = turf.union(walkableArea, s);
      // });

      // ★★★ 自作の正方形分割関数を呼び出すように変更 ★★★
      if (!walkableArea) {
        console.warn(`歩行可能エリアの生成に失敗したため、メッシュ分割をスキップします:`, frameId);
      }
      
      const cellSize = 10; // 正方形の一辺の長さ（ピクセル）
      const gridFeatures = createSquareGridInPolygon(walkableArea, cellSize);
      const finalGeoJson = turf.featureCollection(gridFeatures);
      
      const fileName = `walkable-quads-${frameId}.geojson`;
      return downloadJson(JSON.stringify(finalGeoJson, null, 2), fileName);

    } catch (e) {
      console.error(e);
      messageEl.textContent = `エラー: ${e.message}`;
      return Promise.reject(e); // エラーをPromiseで返す
    }
  }


  // code.tsからメッセージを受け取る
  window.onmessage = (event) => {
    const msg = event.data.pluginMessage;
    
    if (msg.type === 'export-geojson-all-floors') {
      allFloorsData = JSON.parse(msg.data);
      filenamePrefix = msg.filenamePrefix;
      messageEl.textContent = `${allFloorsData.length}フロア分のデータを受信しました。`;
      
      masterButtonsArea.style.display = 'block'; // 一括ボタンを表示
      separatedButtonsArea.innerHTML = ''; // 個別ボタンをクリア

      allFloorsData.forEach(floorData => {
        // ... (個別ボタンのHTML要素を作成する処理は変更なし) ...
        // ★★★ 変更点: ボタンを動的に生成する ★★★

        const floorId = floorData.frameId;
        const floorGeoJson = floorData.geoJson;

        // フロアごとのコンテナを作成
        const groupDiv = document.createElement('div');
        groupDiv.className = 'floor-group';

        const title = document.createElement('p');
        title.className = 'floor-title';
        title.textContent = floorId;
        groupDiv.appendChild(title);

        const buttonsDiv = document.createElement('div');
        buttonsDiv.className = 'floor-buttons';

        const geoJsonButton = document.createElement('button');
        geoJsonButton.textContent = 'GeoJSON保存';
        // ★ 個別ボタンのクリックイベントに関数を紐付け
        geoJsonButton.onclick = () => {
            messageEl.textContent = `${floorData.frameId} のGeoJSONを保存しています...`;
            handleSaveGeoJson(floorData).then(() => {
                messageEl.textContent = `${floorData.frameId} のGeoJSONを保存しました。`;
            });
        };

        const walkableButton = document.createElement('button');
        walkableButton.textContent = '歩行可能エリア生成';
        walkableButton.className = 'walkable';
        // ★ 個別ボタンのクリックイベントに関数を紐付け
        walkableButton.onclick = () => {
            messageEl.textContent = `${floorData.frameId} の歩行可能エリアを生成しています...`;
            handleGenerateWalkable(floorData).then(() => {
                messageEl.textContent = `${floorData.frameId} の歩行可能エリアを生成しました。`;
            });
        };
        
        // ... (作成したボタンをDOMに追加する処理は変更なし) ...
        buttonsDiv.appendChild(geoJsonButton);
        buttonsDiv.appendChild(walkableButton);

        groupDiv.appendChild(buttonsDiv);
        separatedButtonsArea.appendChild(groupDiv);
      });

    } else if (msg.type === 'error') {
      messageEl.textContent = msg.message;
    }
  };

  // ★★★ 一括ボタンのクリックイベントを定義 ★★★

  // 全てのGeoJSONを一括保存
  exportAllMasterButton.onclick = async () => {
    if (!allFloorsData) return;
    messageEl.textContent = "全フロアのGeoJSONを一括保存中...";
    exportAllMasterButton.disabled = true;

    // 個別のボタン要素を探して、順番にクリックイベントを発火させるのと同じ
    for (const floor of allFloorsData) {
      await handleSaveGeoJson(floor);
    }

    messageEl.textContent = "全フロアの保存が完了しました。";
    exportAllMasterButton.disabled = false;
  };

  // 全ての歩行可能エリアを一括生成
  generateAllMasterButton.onclick = async () => {
    if (!allFloorsData) return;
    messageEl.textContent = "全フロアの歩行可能エリアを一括生成中...";
    generateAllMasterButton.disabled = true;

    // 個別のボタン要素を探して、順番にクリックイベントを発火させるのと同じ
    for (const floor of allFloorsData) {
      await handleGenerateWalkable(floor);
    }
    
    messageEl.textContent = "全フロアの生成が完了しました。";
    generateAllMasterButton.disabled = false;
  };
</script>