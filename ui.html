<style>
  body { font-family: sans-serif; text-align: center; padding: 16px; }
  button {
    background-color: #0d99ff; color: white; border: none; padding: 10px 20px;
    border-radius: 4px; font-size: 14px; cursor: pointer; display: block; width: 100%; margin-bottom: 8px;
  }
  button:disabled { background-color: #e0e0e0; cursor: not-allowed; }
  p { font-size: 12px; color: #555; }
  /* ★ 追加: 一括ボタン用のスタイル */
  .master-buttons { border-bottom: 2px solid #0d99ff; padding-bottom: 16px; margin-bottom: 16px; }
  .master-buttons button.walkable { background-color: #28a745; }

  .floor-group { border: 1px solid #ccc; border-radius: 8px; padding: 12px; margin-bottom: 12px; }
  .floor-title { font-weight: bold; margin-bottom: 8px; }
  .floor-buttons { display: flex; gap: 8px; }
  .floor-buttons button { width: 50%; font-size: 12px; padding: 8px; }
  .floor-buttons button.walkable { background-color: #28a745; }
</style>

<h2>GeoJSON エクスポート</h2>
<p id="message">データを待っています...</p>

<div id="master-buttons-area" class="master-buttons" style="display: none;">
  <button id="export-all-master-button">全てのGeoJSONを一括保存</button>
  <button id="generate-all-master-button" class="walkable">全ての歩行可能エリアを一括生成</button>
</div>
<div id="separated-buttons-area"></div>

<script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>
<script>
  const masterButtonsArea = document.getElementById('master-buttons-area');
  const exportAllMasterButton = document.getElementById('export-all-master-button');
  const generateAllMasterButton = document.getElementById('generate-all-master-button');
  const separatedButtonsArea = document.getElementById('separated-buttons-area');
  const messageEl = document.getElementById('message');
  
  let allFloorsData = null;
  let filenamePrefix = 'map';

  // (downloadJson関数とfixWindingOrder関数は変更なし)
  function downloadJson(jsonData, fileName) {
    const blob = new Blob([jsonData], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url; link.download = fileName;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    return new Promise(resolve => setTimeout(resolve, 100));
  }

  function fixWindingOrder(geoJsonData) {
    const correctedFeatures = geoJsonData.features.map((feature) => {
      return turf.rewind(feature, { inplace: false });
    });
    return { type: 'FeatureCollection', features: correctedFeatures };
  }

  // ★★★ 追加: ピクセル座標で円ポリゴンを生成するヘルパー関数 ★★★
  /**
   * 中心点と半径（ピクセル単位）から、円を近似するポリゴンフィーチャーを作成します。
   * @param {number[]} center - [x, y]の中心座標
   * @param {number} radius - 半径 (ピクセル)
   * @param {object} properties - フィーチャーに付与するプロパティ
   * @returns {object} GeoJSONのPolygon Feature
   */
  function createCirclePolygon(center, radius, properties) {
    const steps = 64; // 円を64角形で近似
    const coordinates = [];
    for (let i = 0; i < steps; i++) {
      const angle = (i / steps) * 2 * Math.PI;
      const x = center[0] + radius * Math.cos(angle);
      const y = center[1] + radius * Math.sin(angle);
      coordinates.push([x, y]);
    }
    coordinates.push(coordinates[0]); // ポリゴンを閉じる
    return turf.polygon([coordinates], properties);
  }

  // ★★★ 追加: 個別処理を関数化 ★★★

  // 1フロア分のGeoJSONを保存する関数
  function handleSaveGeoJson(floorData) {
    const corrected = fixWindingOrder(floorData.geoJson);
    const fileName = `${floorData.frameId}.geojson`;
    return downloadJson(JSON.stringify(corrected, null, 2), fileName);
  }

  // 1フロア分の歩行可能エリアを生成・保存する関数
  function handleGenerateWalkable(floorData) {
    try {
      const { frameId, geoJson } = floorData;
      const base = geoJson.features.find(f => f.properties.id === 'base');
      if (!base) {
        throw new Error(`フロア "${frameId}" に "base" が見つかりません。`);
      }
      // const stairs = geoJson.features.filter(f => f.properties.id.includes('stairs'));
      const pre_obstacles = geoJson.features.filter(f => f.properties.id !== 'base' && !f.properties.id.includes('stairs'));
      // 障害物リストの中にある円（Point）をポリゴンに変換
      // ★ 変更点: turf.circleの代わりに自作関数を使う
      const obstacles = pre_obstacles.map(obstacle => {
          if (obstacle.geometry.type === 'Point' && obstacle.properties.radius) {
              const center = obstacle.geometry.coordinates;
              const radius = obstacle.properties.radius;
              // ★ 自作のcreateCirclePolygon関数を呼び出す
              return createCirclePolygon(center, radius, obstacle.properties);
          }
          return obstacle;
      });

      let walkableArea = base;
      obstacles.forEach(obs => {
        // ★★★ デバッグ用のチェックを追加 ★★★
        const doTheyOverlap = turf.booleanOverlap(walkableArea, obs);
        const isContained = turf.booleanContains(walkableArea, obs);

        // console.log(`障害物チェック: ${obs.properties.id}`);
        // console.log(`  - 重なっていますか？ -> ${doTheyOverlap}`);
        // console.log(`  - 床に完全に含まれていますか？ -> ${isContained}`);
        
        if (!isContained && !doTheyOverlap) {
          console.log(`障害物チェック: ${obs.properties.id}`);
          console.error(`  - 警告: この障害物は床ポリゴンと重なっていないため、引き算できません！座標を確認してください。`);
          console.log(obs);
        }
        // ★★★ チェックここまで ★★★

        // 安全のため、演算の前に両方のジオメトリをクリーンアップ
        const cleanedWalkable = turf.cleanCoords(walkableArea);
        const cleanedObs = turf.cleanCoords(obs);

        // turf.difference(polygon1, polygon2) の形で呼び出す
        // turf.differenceはnullを返すことがあるので、結果をチェック
        const result = turf.difference(turf.featureCollection([cleanedWalkable, cleanedObs]));
        
        if (result) {
          walkableArea = result;
        } else {
          console.warn(`差分計算に失敗しました。障害物オブジェクトを確認してください:`, obs.properties.id);
        }
      });
      // stairs.forEach(s => {
      //   walkableArea = turf.union(walkableArea, s);
      // });
      
      // walkableArea.properties = { ...walkableArea.properties, name: `${frameId}-walkable` };
      const finalGeoJson = { type: "FeatureCollection", features: [walkableArea] };
      const fileName = `walkable-area-${frameId}.geojson`;
      return downloadJson(JSON.stringify(finalGeoJson, null, 2), fileName);
    } catch (e) {
      console.error(e);
      messageEl.textContent = `エラー: ${e.message}`;
      return Promise.reject(e); // エラーをPromiseで返す
    }
  }


  // code.tsからメッセージを受け取る
  window.onmessage = (event) => {
    const msg = event.data.pluginMessage;
    
    if (msg.type === 'export-geojson-all-floors') {
      allFloorsData = JSON.parse(msg.data);
      filenamePrefix = msg.filenamePrefix;
      messageEl.textContent = `${allFloorsData.length}フロア分のデータを受信しました。`;
      
      masterButtonsArea.style.display = 'block'; // 一括ボタンを表示
      separatedButtonsArea.innerHTML = ''; // 個別ボタンをクリア

      allFloorsData.forEach(floorData => {
        // ... (個別ボタンのHTML要素を作成する処理は変更なし) ...
        // ★★★ 変更点: ボタンを動的に生成する ★★★

        const floorId = floorData.frameId;
        const floorGeoJson = floorData.geoJson;

        // フロアごとのコンテナを作成
        const groupDiv = document.createElement('div');
        groupDiv.className = 'floor-group';

        const title = document.createElement('p');
        title.className = 'floor-title';
        title.textContent = floorId;
        groupDiv.appendChild(title);

        const buttonsDiv = document.createElement('div');
        buttonsDiv.className = 'floor-buttons';

        const geoJsonButton = document.createElement('button');
        geoJsonButton.textContent = 'GeoJSON保存';
        // ★ 個別ボタンのクリックイベントに関数を紐付け
        geoJsonButton.onclick = () => {
            messageEl.textContent = `${floorData.frameId} のGeoJSONを保存しています...`;
            handleSaveGeoJson(floorData).then(() => {
                messageEl.textContent = `${floorData.frameId} のGeoJSONを保存しました。`;
            });
        };

        const walkableButton = document.createElement('button');
        walkableButton.textContent = '歩行可能エリア生成';
        walkableButton.className = 'walkable';
        // ★ 個別ボタンのクリックイベントに関数を紐付け
        walkableButton.onclick = () => {
            messageEl.textContent = `${floorData.frameId} の歩行可能エリアを生成しています...`;
            handleGenerateWalkable(floorData).then(() => {
                messageEl.textContent = `${floorData.frameId} の歩行可能エリアを生成しました。`;
            });
        };
        
        // ... (作成したボタンをDOMに追加する処理は変更なし) ...
        buttonsDiv.appendChild(geoJsonButton);
        buttonsDiv.appendChild(walkableButton);

        groupDiv.appendChild(buttonsDiv);
        separatedButtonsArea.appendChild(groupDiv);
      });

    } else if (msg.type === 'error') {
      messageEl.textContent = msg.message;
    }
  };

  // ★★★ 一括ボタンのクリックイベントを定義 ★★★

  // 全てのGeoJSONを一括保存
  exportAllMasterButton.onclick = async () => {
    if (!allFloorsData) return;
    messageEl.textContent = "全フロアのGeoJSONを一括保存中...";
    exportAllMasterButton.disabled = true;

    // 個別のボタン要素を探して、順番にクリックイベントを発火させるのと同じ
    for (const floor of allFloorsData) {
      await handleSaveGeoJson(floor);
    }

    messageEl.textContent = "全フロアの保存が完了しました。";
    exportAllMasterButton.disabled = false;
  };

  // 全ての歩行可能エリアを一括生成
  generateAllMasterButton.onclick = async () => {
    if (!allFloorsData) return;
    messageEl.textContent = "全フロアの歩行可能エリアを一括生成中...";
    generateAllMasterButton.disabled = true;

    // 個別のボタン要素を探して、順番にクリックイベントを発火させるのと同じ
    for (const floor of allFloorsData) {
      await handleGenerateWalkable(floor);
    }
    
    messageEl.textContent = "全フロアの生成が完了しました。";
    generateAllMasterButton.disabled = false;
  };
</script>